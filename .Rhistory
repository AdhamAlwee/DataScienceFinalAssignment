print(recommendations)
return(recommendations)
}
# Example usage
check_missing_data(movies_data)
result <- separate_and_list_genres(movies_data)
head(result$separated_data)
# Get recommendations
recommend_movies(movies_data, "Toy Story (1995)", 10)
# Load necessary libraries
library(shiny)
library(bslib)
library(naniar)
library(VIM)
library(ggplot2)
library(recommenderlab)
library(caret)
library(dplyr)
library(tidyr)  # Added for separate_rows()
library(stringr)  # Added for text processing
library(proxy)  # Added for cosine similarity
# Get filepath
setwd("C:/Users/user/OneDrive - Universiti Teknologi PETRONAS/Jan 25/Data Science/Project Assignment/DataScienceFinalAssignment")
getwd()
# URL for folder and filename
folderpath <- "datasets"
links <- "links.csv"
movies <- "movies.csv"
ratings <- "ratings.csv"
tags <- "tags.csv"
# Function to import CSV files
import_data <- function(subfolder, filename) {
file_path <- file.path(subfolder, filename)  # Construct the relative path
data <- read.csv(file_path, stringsAsFactors = FALSE)
return(data)
}
# Import datasets
movies_data <- import_data(folderpath, movies)
tags_data <- import_data(folderpath, tags)
# Function to check missing data
check_missing_data <- function(data) {
if (!is.data.frame(data)) {
stop("Input must be a data.frame")
}
# Count missing values per column
missing_counts <- colSums(is.na(data))
missing_percent <- (missing_counts / nrow(data)) * 100  # Percentage of missing values
# Create a summary table
missing_summary <- data.frame(
Column = names(data),
Missing_Values = missing_counts,
Missing_Percentage = missing_percent
)
# Filter only columns with missing values
missing_summary <- missing_summary[missing_summary$Missing_Values > 0, ]
# Print summary
if (nrow(missing_summary) == 0) {
print("No missing values found!")
} else {
print(missing_summary)
# Plot missing data visualization
print(gg_miss_var(data))  # naniar visualization
aggr(data, col = c("navyblue", "red"), numbers = TRUE, sortVars = TRUE, cex.axis = 0.7, gap = 3, ylab = c("Missing data", "Pattern"))  # VIM visualization
}
return(missing_summary)
}
# Function to separate genres and list unique genres
separate_and_list_genres <- function(data) {
if (!"genres" %in% colnames(data)) {
stop("The dataset must contain a 'genres' column")
}
# Separate genres into multiple rows
separated_data <- data %>% separate_rows(genres, sep = "\\|")
# Get unique genres
unique_genres <- unique(separated_data$genres)
# Print the unique genres
print("Unique Genres:")
print(unique_genres)
return(list(separated_data = separated_data, unique_genres = unique_genres))
}
# Function to recommend movies based on genre similarity using cosine similarity
recommend_movies <- function(data, movie_title, num_recommendations = 10) {
if (!"title" %in% colnames(data) || !"genres" %in% colnames(data)) {
stop("The dataset must contain 'title' and 'genres' columns")
}
# Separate genres into multiple rows
data <- data %>% separate_rows(genres, sep = "\\|")
# Create a binary matrix for genres
genre_matrix <- data %>%
mutate(value = 1) %>%
spread(key = genres, value = value, fill = 0)
# Remove duplicate movie titles
genre_matrix <- genre_matrix %>% group_by(title) %>% summarise(across(where(is.numeric), max))
# Find the index of the input movie
movie_index <- which(genre_matrix$title == movie_title)
if (length(movie_index) == 0) {
stop("Movie not found in dataset")
}
# Compute cosine similarity and convert to matrix
similarity_matrix <- as.matrix(proxy::dist(genre_matrix[,-1], method = "cosine"))
# Extract the similarity scores for the input movie
movie_similarities <- similarity_matrix[movie_index, ]
# Get top recommendations
recommendations <- genre_matrix$title[order(movie_similarities)[2:(num_recommendations + 1)]]
print("Recommended Movies:")
print(recommendations)
return(recommendations)
}
# Example usage
check_missing_data(movies_data)
result <- separate_and_list_genres(movies_data)
head(result$separated_data)
# Get recommendations
recommend_movies(movies_data, "Toy Story (1995)", 10)
# Load necessary libraries
library(shiny)
library(bslib)
library(naniar)
library(VIM)
library(ggplot2)
library(recommenderlab)
library(caret)
library(dplyr)
library(tidyr)  # Added for separate_rows()
library(stringr)  # Added for text processing
library(proxy)  # Added for cosine similarity
# Get filepath
setwd("C:/Users/user/OneDrive - Universiti Teknologi PETRONAS/Jan 25/Data Science/Project Assignment/DataScienceFinalAssignment")
getwd()
# URL for folder and filename
folderpath <- "datasets"
links <- "links.csv"
movies <- "movies.csv"
ratings <- "ratings.csv"
tags <- "tags.csv"
# Function to import CSV files
import_data <- function(subfolder, filename) {
file_path <- file.path(subfolder, filename)  # Construct the relative path
data <- read.csv(file_path, stringsAsFactors = FALSE)
return(data)
}
# Import datasets
movies_data <- import_data(folderpath, movies)
tags_data <- import_data(folderpath, tags)
ratings_data <- import_data(folderpath, ratings)
# Function to check missing data
check_missing_data <- function(data) {
if (!is.data.frame(data)) {
stop("Input must be a data.frame")
}
# Count missing values per column
missing_counts <- colSums(is.na(data))
missing_percent <- (missing_counts / nrow(data)) * 100  # Percentage of missing values
# Create a summary table
missing_summary <- data.frame(
Column = names(data),
Missing_Values = missing_counts,
Missing_Percentage = missing_percent
)
# Filter only columns with missing values
missing_summary <- missing_summary[missing_summary$Missing_Values > 0, ]
# Print summary
if (nrow(missing_summary) == 0) {
print("No missing values found!")
} else {
print(missing_summary)
# Plot missing data visualization
print(gg_miss_var(data))  # naniar visualization
aggr(data, col = c("navyblue", "red"), numbers = TRUE, sortVars = TRUE, cex.axis = 0.7, gap = 3, ylab = c("Missing data", "Pattern"))  # VIM visualization
}
return(missing_summary)
}
# Function to separate genres and list unique genres
separate_and_list_genres <- function(data) {
if (!"genres" %in% colnames(data)) {
stop("The dataset must contain a 'genres' column")
}
# Separate genres into multiple rows
separated_data <- data %>% separate_rows(genres, sep = "\\|")
# Get unique genres
unique_genres <- unique(separated_data$genres)
# Print the unique genres
print("Unique Genres:")
print(unique_genres)
return(list(separated_data = separated_data, unique_genres = unique_genres))
}
# Function to recommend movies based on genre similarity using cosine similarity
recommend_movies <- function(data, movie_title, num_recommendations = 10) {
if (!"title" %in% colnames(data) || !"genres" %in% colnames(data)) {
stop("The dataset must contain 'title' and 'genres' columns")
}
# Separate genres into multiple rows
data <- data %>% separate_rows(genres, sep = "\\|")
# Create a binary matrix for genres
genre_matrix <- data %>%
mutate(value = 1) %>%
spread(key = genres, value = value, fill = 0)
# Remove duplicate movie titles
genre_matrix <- genre_matrix %>% group_by(title) %>% summarise(across(where(is.numeric), max))
# Find the index of the input movie
movie_index <- which(genre_matrix$title == movie_title)
if (length(movie_index) == 0) {
stop("Movie not found in dataset")
}
# Compute cosine similarity
similarity_scores <- proxy::dist(genre_matrix[,-1], method = "cosine")
# Extract the similarity scores for the input movie
movie_similarities <- similarity_scores[movie_index, ]
# Get top recommendations
recommendations <- genre_matrix$title[order(movie_similarities)[2:(num_recommendations + 1)]]
print("Recommended Movies:")
print(recommendations)
return(recommendations)
}
# Function to calculate RMSE
evaluate_rmse <- function(actual_ratings, predicted_ratings) {
sqrt(mean((actual_ratings - predicted_ratings)^2, na.rm = TRUE))
}
# Function to calculate Precision and Recall
evaluate_precision_recall <- function(recommended_movies, actual_movies) {
true_positives <- sum(recommended_movies %in% actual_movies)
precision <- true_positives / length(recommended_movies)
recall <- true_positives / length(actual_movies)
return(list(precision = precision, recall = recall))
}
# Shiny App UI and Server
ui <- fluidPage(
titlePanel("Movie Recommendation System"),
sidebarLayout(
sidebarPanel(
textInput("movie_title", "Enter Movie Title:", "Toy Story (1995)"),
numericInput("num_recommendations", "Number of Recommendations:", 10, min = 1, max = 20),
actionButton("recommend", "Get Recommendations")
),
mainPanel(
verbatimTextOutput("recommendation_output")
)
server <- function(input, output) {
observeEvent(input$recommend, {
recommendations <- recommend_movies(movies_data, input$movie_title, input$num_recommendations)
output$recommendation_output <- renderPrint(recommendations)
})
}
shinyApp(ui, server)
runApp('Source.R')
# Load necessary libraries
library(shiny)
library(bslib)
library(naniar)
library(VIM)
library(ggplot2)
library(recommenderlab)
library(caret)
library(dplyr)
library(tidyr)  # Added for separate_rows()
library(stringr)  # Added for text processing
library(proxy)  # Added for cosine similarity
# Get filepath
setwd("C:/Users/user/OneDrive - Universiti Teknologi PETRONAS/Jan 25/Data Science/Project Assignment/DataScienceFinalAssignment")
getwd()
# URL for folder and filename
folderpath <- "datasets"
links <- "links.csv"
movies <- "movies.csv"
ratings <- "ratings.csv"
tags <- "tags.csv"
# Function to import CSV files
import_data <- function(subfolder, filename) {
file_path <- file.path(subfolder, filename)  # Construct the relative path
data <- read.csv(file_path, stringsAsFactors = FALSE)
return(data)
}
# Import datasets
movies_data <- import_data(folderpath, movies)
tags_data <- import_data(folderpath, tags)
ratings_data <- import_data(folderpath, ratings)
# Function to check missing data
check_missing_data <- function(data) {
if (!is.data.frame(data)) {
stop("Input must be a data.frame")
}
# Count missing values per column
missing_counts <- colSums(is.na(data))
missing_percent <- (missing_counts / nrow(data)) * 100  # Percentage of missing values
# Create a summary table
missing_summary <- data.frame(
Column = names(data),
Missing_Values = missing_counts,
Missing_Percentage = missing_percent
)
# Filter only columns with missing values
missing_summary <- missing_summary[missing_summary$Missing_Values > 0, ]
# Print summary
if (nrow(missing_summary) == 0) {
print("No missing values found!")
} else {
print(missing_summary)
# Plot missing data visualization
print(gg_miss_var(data))  # naniar visualization
aggr(data, col = c("navyblue", "red"), numbers = TRUE, sortVars = TRUE, cex.axis = 0.7, gap = 3, ylab = c("Missing data", "Pattern"))  # VIM visualization
}
return(missing_summary)
}
# Function to separate genres and list unique genres
separate_and_list_genres <- function(data) {
if (!"genres" %in% colnames(data)) {
stop("The dataset must contain a 'genres' column")
}
# Separate genres into multiple rows
separated_data <- data %>% separate_rows(genres, sep = "\\|")
# Get unique genres
unique_genres <- unique(separated_data$genres)
# Print the unique genres
print("Unique Genres:")
print(unique_genres)
return(list(separated_data = separated_data, unique_genres = unique_genres))
}
# Function to recommend movies based on genre similarity using cosine similarity
recommend_movies <- function(data, movie_title, num_recommendations = 10) {
if (!"title" %in% colnames(data) || !"genres" %in% colnames(data)) {
stop("The dataset must contain 'title' and 'genres' columns")
}
# Separate genres into multiple rows
data <- data %>% separate_rows(genres, sep = "\\|")
# Create a binary matrix for genres
genre_matrix <- data %>%
mutate(value = 1) %>%
spread(key = genres, value = value, fill = 0)
# Remove duplicate movie titles
genre_matrix <- genre_matrix %>% group_by(title) %>% summarise(across(where(is.numeric), max))
# Find the index of the input movie
movie_index <- which(genre_matrix$title == movie_title)
if (length(movie_index) == 0) {
stop("Movie not found in dataset")
}
# Compute cosine similarity
similarity_matrix <- proxy::simil(as.matrix(genre_matrix[,-1]), method = "cosine")
# Extract similarity scores for the input movie
movie_similarities <- similarity_matrix[movie_index, ]
# Get top recommendations (excluding itself)
recommendations <- genre_matrix$title[order(-movie_similarities)][2:(num_recommendations + 1)]
print("Recommended Movies:")
print(recommendations)
return(recommendations)
}
# Function to calculate RMSE
evaluate_rmse <- function(actual_ratings, predicted_ratings) {
sqrt(mean((actual_ratings - predicted_ratings)^2, na.rm = TRUE))
}
# Function to calculate Precision and Recall
evaluate_precision_recall <- function(recommended_movies, actual_movies) {
true_positives <- sum(recommended_movies %in% actual_movies)
precision <- true_positives / length(recommended_movies)
recall <- true_positives / length(actual_movies)
return(list(precision = precision, recall = recall))
}
# Shiny App UI and Server
ui <- fluidPage(
titlePanel("Movie Recommendation System"),
sidebarLayout(
sidebarPanel(
textInput("movie_title", "Enter Movie Title:", "Toy Story (1995)"),
numericInput("num_recommendations", "Number of Recommendations:", 10, min = 1, max = 20),
actionButton("recommend", "Get Recommendations")
),
mainPanel(
verbatimTextOutput("recommendation_output")
)
server <- function(input, output) {
observeEvent(input$recommend, {
recommendations <- recommend_movies(movies_data, input$movie_title, input$num_recommendations)
output$recommendation_output <- renderPrint(recommendations)
})
}
shinyApp(ui, server)
# Load necessary libraries
library(shiny)
library(bslib)
library(naniar)
library(VIM)
library(ggplot2)
library(recommenderlab)
library(caret)
library(dplyr)
library(tidyr)  # Added for separate_rows()
library(stringr)  # Added for text processing
library(proxy)  # Added for cosine similarity
# Get filepath
setwd("C:/Users/user/OneDrive - Universiti Teknologi PETRONAS/Jan 25/Data Science/Project Assignment/DataScienceFinalAssignment")
getwd()
# URL for folder and filename
folderpath <- "datasets"
links <- "links.csv"
movies <- "movies.csv"
ratings <- "ratings.csv"
tags <- "tags.csv"
# Function to import CSV files
import_data <- function(subfolder, filename) {
file_path <- file.path(subfolder, filename)  # Construct the relative path
data <- read.csv(file_path, stringsAsFactors = FALSE)
return(data)
}
# Import datasets
movies_data <- import_data(folderpath, movies)
tags_data <- import_data(folderpath, tags)
ratings_data <- import_data(folderpath, ratings)
# Function to check missing data
check_missing_data <- function(data) {
if (!is.data.frame(data)) {
stop("Input must be a data.frame")
}
# Count missing values per column
missing_counts <- colSums(is.na(data))
missing_percent <- (missing_counts / nrow(data)) * 100  # Percentage of missing values
# Create a summary table
missing_summary <- data.frame(
Column = names(data),
Missing_Values = missing_counts,
Missing_Percentage = missing_percent
)
# Filter only columns with missing values
missing_summary <- missing_summary[missing_summary$Missing_Values > 0, ]
# Print summary
if (nrow(missing_summary) == 0) {
print("No missing values found!")
} else {
print(missing_summary)
# Plot missing data visualization
print(gg_miss_var(data))  # naniar visualization
aggr(data, col = c("navyblue", "red"), numbers = TRUE, sortVars = TRUE, cex.axis = 0.7, gap = 3, ylab = c("Missing data", "Pattern"))  # VIM visualization
}
return(missing_summary)
}
# Function to separate genres and list unique genres
separate_and_list_genres <- function(data) {
if (!"genres" %in% colnames(data)) {
stop("The dataset must contain a 'genres' column")
}
# Separate genres into multiple rows
separated_data <- data %>% separate_rows(genres, sep = "\\|")
# Get unique genres
unique_genres <- unique(separated_data$genres)
# Print the unique genres
print("Unique Genres:")
print(unique_genres)
return(list(separated_data = separated_data, unique_genres = unique_genres))
}
# Function to recommend movies based on genre similarity using cosine similarity
recommend_movies <- function(data, movie_title, num_recommendations = 10) {
if (!"title" %in% colnames(data) || !"genres" %in% colnames(data)) {
stop("The dataset must contain 'title' and 'genres' columns")
}
# Separate genres into multiple rows
data <- data %>% separate_rows(genres, sep = "\\|")
# Create a binary matrix for genres
genre_matrix <- data %>%
mutate(value = 1) %>%
spread(key = genres, value = value, fill = 0)
# Remove duplicate movie titles
genre_matrix <- genre_matrix %>% group_by(title) %>% summarise(across(where(is.numeric), max))
# Find the index of the input movie
movie_index <- which(genre_matrix$title == movie_title)
if (length(movie_index) == 0) {
stop("Movie not found in dataset")
}
# Compute cosine similarity
similarity_matrix <- proxy::simil(as.matrix(genre_matrix[,-1]), method = "cosine")
# Extract similarity scores for the input movie
movie_similarities <- similarity_matrix[movie_index, ]
# Get top recommendations (excluding itself)
recommendations <- genre_matrix$title[order(-movie_similarities)][2:(num_recommendations + 1)]
print("Recommended Movies:")
print(recommendations)
return(recommendations)
}
# Function to calculate RMSE
evaluate_rmse <- function(actual_ratings, predicted_ratings) {
sqrt(mean((actual_ratings - predicted_ratings)^2, na.rm = TRUE))
}
# Function to calculate Precision and Recall
evaluate_precision_recall <- function(recommended_movies, actual_movies) {
true_positives <- sum(recommended_movies %in% actual_movies)
precision <- true_positives / length(recommended_movies)
recall <- true_positives / length(actual_movies)
return(list(precision = precision, recall = recall))
}
# Shiny App UI and Server
ui <- fluidPage(
titlePanel("Movie Recommendation System"),
sidebarLayout(
sidebarPanel(
textInput("movie_title", "Enter Movie Title:", "Toy Story (1995)"),
numericInput("num_recommendations", "Number of Recommendations:", 10, min = 1, max = 20),
actionButton("recommend", "Get Recommendations")
),
mainPanel(
verbatimTextOutput("recommendation_output")
)
server <- function(input, output) {
observeEvent(input$recommend, {
recommendations <- recommend_movies(movies_data, input$movie_title, input$num_recommendations)
output$recommendation_output <- renderPrint(recommendations)
})
}
shinyApp(ui, server)
library(tidyverse)
library(proxy)
library(stringr)
library(shiny)
library(bslib)
# Load and preprocess the dataset
movies_data <- read.csv("movies.csv", stringsAsFactors = FALSE)
