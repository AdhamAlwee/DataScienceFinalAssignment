labs(title = "Fare Variation by Vehicle Type", x = "Vehicle Type", y = "Fare_per_Mile") +
theme_minimal()
rlang::last_trace()
source("C:/Users/user/OneDrive - Universiti Teknologi PETRONAS/Jan 25/Data Science/DS Assignment Jeremy/DS Assignment 4.R")
#5. Payment and User Behavior
#Most common payment methods.
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Payment Method`, fill = `Payment Method`)) +
geom_bar() +
labs(title = "Most Common Payment Methods", x = "Payment Method", y = "Count") +
theme_minimal()
#User rating distribution and its relationship with traffic conditions or peak hours.
#User Rating Distribution
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `User Rating`)) +
geom_histogram(binwidth = 0.5, fill = "blue", color = "black", alpha = 0.7) +
labs(title = "User Rating Distribution", x = "User Rating", y = "Count") +
theme_minimal()
#Relationship Between User Ratings & Traffic Conditions
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Traffic Condition`, y = `User Rating`, fill = `Traffic Condition`)) +
geom_boxplot() +
labs(title = "User Rating vs. Traffic Conditions", x = "Traffic Condition", y = "User Rating") +
theme_minimal()
#Relationship Between User Ratings & Peak Hours
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Peak Hours`, y = `User Rating`, fill = `Peak Hours`)) +
geom_boxplot() +
labs(title = "User Rating vs. Peak Hours", x = "Peak Hours (Yes/No)", y = "User Rating") +
theme_minimal()
#6. Traffic and Ride Patterns
#Effect of traffic conditions on ride distance.
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Traffic Condition`, y = `Ride Distance (in miles)`, fill = `Traffic Condition`)) +
geom_boxplot() +
labs(title = "Effect of Traffic on Ride Distance", x = "Traffic Condition", y = "Ride Distance (miles)") +
theme_minimal()
#6. Traffic and Ride Patterns
#Effect of traffic conditions on ride distance.
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Traffic Condition`, y = `Ride Distance (in miles)`, fill = `Traffic Condition`)) +
geom_boxplot() +
labs(title = "Effect of Traffic on Ride Distance", x = "Traffic Condition", y = "Ride Distance (miles)") +
theme_minimal()
#Ride frequency during peak hours vs. non-peak hours.
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Peak Hours`, fill = `Peak Hours`)) +
geom_bar() +
labs(title = "Ride Frequency: Peak vs. Non-Peak Hours", x = "Peak Hours (Yes/No)", y = "Number of Rides") +
theme_minimal()
#4. Fare and Distance Analysis
#Distribution of ride distances and fare amounts.
#Create classes of data using cut function as histogram was too messy to analyse
Copy_of_Ride_Sharing_Dataset <- Copy_of_Ride_Sharing_Dataset %>%
mutate(Distance_Category = cut(`Ride Distance (in miles)`,
breaks = c(0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000, 10500, 11000, 11500, 12000, 12500, Inf),  # Define class ranges
labels = c("0-500 miles", "500-1000 miles", "1000-1500 miles", "1500-2000 miles", "2000-2500 miles", "2500-3000 miles", "3000-3500 miles", "3500-4000 miles", "4000-4500 miles", "4500-5000 miles", "5000-5500 miles", "5500-6000 miles", "6000-6500 miles", "6500-7000 miles", "7000-7500 miles", "7500-8000 miles", "8000-8500 miles", "8500-9000 miles", "9000-9500 miles", "9500-10000 miles", "10000-10500 miles", "10500-11000 miles", "11000-11500 miles", "11500-12000 miles", "12000-12500 miles", "12500+ miles"),
right = FALSE))  # Right-closed intervals (e.g., 0-2 includes 0 but not 2)
#Bar Chart of Ride Distances
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = Distance_Category)) +
geom_bar(fill = "blue", color = "black", alpha = 0.7) +
labs(title = "Ride Distance Distribution by Category",
x = "Ride Distance Category",
y = "Count") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
#Histogram of Fare Amounts
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Fare Amount (in $)`)) +
geom_histogram(binwidth = 5, fill = "green", color = "black", alpha = 0.7) +
labs(title = "Distribution of Fare Amounts", x = "Fare Amount ($)", y = "Count") +
theme_minimal()
#Correlation between ride distance and fare amount.
#We check if longer rides result in higher fares.
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Ride Distance (in miles)`, y = `Fare Amount (in $)`)) +
geom_point(alpha = 0.5, color = "blue") +
geom_smooth(method = "lm", color = "red") +
labs(title = "Correlation Between Ride Distance and Fare", x = "Ride Distance (miles)", y = "Fare Amount ($)") +
theme_minimal()
#Calculate Correlation Coefficient(gradient, essentially, closer to 1 means stronger positive relation)
cor(Copy_of_Ride_Sharing_Dataset$'Ride Distance (in miles)', Copy_of_Ride_Sharing_Dataset$'Fare Amount (in $)', use = "complete.obs")
#Fare variation based on vehicle type and traffic conditions.
#Boxplot of Fare by Vehicle Type
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Vehicle Type`, y = `Fare_per_Mile`, fill = `Vehicle Type`)) +
geom_boxplot() +
labs(title = "Fare Variation by Vehicle Type", x = "Vehicle Type", y = "Fare_per_Mile") +
theme_minimal()
library(ggplot2)
library(dplyr)
library(tidyverse)
#Create New Fare per Mile column to remove influence of ride distance on fare amount
Copy_of_Ride_Sharing_Dataset <- Copy_of_Ride_Sharing_Dataset %>%
mutate(Fare_per_Mile = `Fare Amount (in $)` / `Ride Distance (in miles)`)
#1. Basic Data Overview
# Count missing values in each column
colSums(is.na(Ride_Sharing_Dataset))
# Summary statistics for numerical columns (yang possible like fare)
summary(Ride_Sharing_Dataset$'Fare Amount (in $)')
library(ggplot2)
library(dplyr)
library(tidyverse)
#Create New Fare per Mile column to remove influence of ride distance on fare amount
Copy_of_Ride_Sharing_Dataset <- Copy_of_Ride_Sharing_Dataset %>%
mutate(Fare_per_Mile = `Fare Amount (in $)` / `Ride Distance (in miles)`)
#1. Basic Data Overview
# Count missing values in each column
colSums(is.na(Copy_of_Ride_Sharing_Dataset))
# Summary statistics for numerical columns (yang possible like fare)
summary(Copy_of_Ride_Sharing_Dataset$'Fare Amount (in $)')
#Unique values in categorical columns.
table(Copy_of_Ride_Sharing_Dataset$'Vehicle Type') #vehicle type
table(Copy_of_Ride_Sharing_Dataset$'Payment Method') #payment method
table(Copy_of_Ride_Sharing_Dataset$'Peak Hours') #Peak Hours
table(Copy_of_Ride_Sharing_Dataset$'Day of Week') #Day of Week
table(Copy_of_Ride_Sharing_Dataset$'Public Holiday') #Public Holiday
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
install.packages("tidyverse")  # Install the entire tidyverse
library(tidyverse)  # Load all included packages
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
install.packages("lubridate")
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#load necessary libs
library(tidyverse)
library(lubridate)
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#Analyze ride frequency by day of the week and/or hour of the day.
# Plot the histogram Number of Rides per hour
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = hour)) +  # ✅ Fix here: Pass the dataset as the first argument
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(title = "Number of Rides by Hour", x = "Hour of the Day", y = "Number of Rides") +
theme_minimal()
#Rides Per Day of the Week
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Day of Week`)) +
geom_bar(fill = "green") +
labs(title = "Rides by Day of the Week", x = "Day", y = "Count")
#Check if public holidays affect ride frequency and fares.
Copy_of_Ride_Sharing_Dataset$'Public Holiday' <- as.factor(Copy_of_Ride_Sharing_Dataset$'Public Holiday')
#Compare Ride Frequency on Holidays vs. Non-Holidays
ride_counts <- Copy_of_Ride_Sharing_Dataset %>%
group_by(`Public Holiday`) %>%
summarise(Ride_Count = n())
print(ride_counts)
ggplot(ride_counts, aes(x = `Public Holiday`, y = Ride_Count, fill = `Public Holiday`)) +
geom_bar(stat = "identity") +
labs(title = "Ride Frequency on Public Holidays vs. Non-Holidays", x = "Public Holiday", y = "Number of Rides") +
theme_minimal()
#Compare Average Fare on Holidays vs. Non-Holidays
fare_comparison <- Copy_of_Ride_Sharing_Dataset %>%
group_by(`Public Holiday`) %>%
summarise(Average_Fare = mean(`Fare Amount (in $)`, na.rm = TRUE))
print(fare_comparison)
# Plot fare amount comparison
ggplot(fare_comparison, aes(x = `Public Holiday`, y = Average_Fare, fill = `Public Holiday`)) +
geom_bar(stat = "identity") +
labs(title = "Average Fare on Public Holidays vs. Non-Holidays", x = "Public Holiday", y = "Average Fare ($)") +
theme_minimal()
#load necessary libs
library(tidyverse)
library(lubridate)
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#Analyze ride frequency by day of the week and/or hour of the day.
#load necessary libs
library(tidyverse)
library(lubridate)
#2. Temporal Analysis
# Convert 'Request Time' to datetime and extract the hour
Copy_of_Ride_Sharing_Dataset$hour <- hour(as.POSIXct(Copy_of_Ride_Sharing_Dataset$'Request Time', format="%Y-%m-%d %H:%M:%S"))
#Analyze ride frequency by day of the week and/or hour of the day.
# Plot the histogram Number of Rides per hour
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = hour)) +  # ✅ Fix here: Pass the dataset as the first argument
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(title = "Number of Rides by Hour", x = "Hour of the Day", y = "Number of Rides") +
theme_minimal()
#Check if public holidays affect ride frequency and fares.
Copy_of_Ride_Sharing_Dataset$'Public Holiday' <- as.factor(Copy_of_Ride_Sharing_Dataset$'Public Holiday')
#Check if public holidays affect ride frequency and fares.
Copy_of_Ride_Sharing_Dataset$'Public Holiday' <- as.factor(Copy_of_Ride_Sharing_Dataset$'Public Holiday')
#Compare Ride Frequency on Holidays vs. Non-Holidays
ride_counts <- Copy_of_Ride_Sharing_Dataset %>%
group_by(`Public Holiday`) %>%
summarise(Ride_Count = n())
print(ride_counts)
ggplot(ride_counts, aes(x = `Public Holiday`, y = Ride_Count, fill = `Public Holiday`)) +
geom_bar(stat = "identity") +
labs(title = "Ride Frequency on Public Holidays vs. Non-Holidays", x = "Public Holiday", y = "Number of Rides") +
theme_minimal()
#3. Geospatial Analysis
#Map pickup and dropoff locations to identify common hotspots.
#Heatmap of pickup locations
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Longitude Pickup`, y = `Latitude Pickup`)) +
geom_density_2d_filled() +
theme_minimal() +
labs(title = "Heatmap of Pickup Locations")
#Compare ride distances across different locations.
#Heatmap of dropoff locations
ggplot(Copy_of_Ride_Sharing_Dataset, aes(x = `Longtitude Dropoff`, y = `Latitude Dropoff`)) +
geom_density_2d_filled() +
theme_minimal() +
labs(title = "Heatmap of Dropoff Locations")
# Lab 8a - Built-ins datasets & Data Visualization in R
# 1. Using sample datasets from library
# 1.1 To see the list of pre-loaded data
data()
# 1.2 Loading the dataset
# Load whole dataset
data(mtcars)
# Print the first 10 rows
print(head(mtcars, 10))
# Store only 2 columns in a variable
input <- mtcars[, c('mpg', 'cyl')]
# Print the first 5 rows
print(head(input))
# 2. Visualizing basic plots
# 2.1 Demonstration of the image-like graphics built-ins of R
demo(graphics)
# Give the chart file a name
png(file = "city.png")
# Plot the chart
pie(x, labels)
# Run in R Console
2+3
print("Hello World!")
# Run in R Script named test.R
# My first program in R Programming
myString <- "Hello, World!"
print(myString)
var.1 <- 5
var_1 <- 7
x <- 1
print(ls())
print(ls(pattern="var"))
# Arithmetic Operations
f <- 3
height <- x
Weight <- 2
b <- 12
c <- 5
print(f+3)
print(height-x)
print(Weight*2)
print(b*2)
print(c^5)
m <- height/100
print(Weight/(m**2))
BMI <- Weight/(m**2)
print(BMI)
print(b%%2)
print(c%%2)
name <- readline(prompt="Enter name: ")
# Convert character to numeric
age <- as.numeric(age)
name <- readline(prompt="Enter name: ")
# Convert character to numeric
age <- as.numeric(age)
print(ls())
age <- readline(prompt="Enter age: ")
name <- readline(prompt="Enter name: ")
age <- as.numeric(age)
name <- readline(prompt="Enter name: ")
age <- as.numeric(age)
21
print(paste("Hi,", name, "this year you are", age, "years old."))
age <- readline(prompt="Enter age: ")
print(paste("Hi,", name, "this year you are", age, "years old."))
# Simple R Code
# Run in R Console
2+3
print("Hello World!")
# Run in R Script named test.R
# My first program in R Programming
myString <- "Hello, World!"
print(myString)
# R Variables
var.1 <- 5
var_1 <- 7
x <- 1
print(ls())
print(ls(pattern="var"))
# Arithmetic Operations
f <- 3
height <- x
Weight <- 2
b <- 12
c <- 5
print(f+3)
print(height-x)
print(Weight*2)
print(b*2)
print(c^5)
m <- height/100
print(Weight/(m**2))
BMI <- Weight/(m**2)
print(BMI)
print(b%%2)
print(c%%2)
# User Input
name <- readline(prompt="Enter name: ")
# Convert character to numeric
age <- as.numeric(age)
print(paste("Hi,", name, "this year you are", age, "years old."))
# Extra
?paste
demo(graphics)
# Task 1: Vector Operations
# 1.1 Vector Construction
# Creating sequences and observing behavior
v <- 5:13
print(v)  # Creates a sequence from 5 to 13
v <- 6.6:12.6
print(v)  # Creates a sequence from 6.6 to 12.6
v <- 3.8:11.4
print(v)  # The last value is discarded as it does not belong to the sequence
print(seq(5, 9, by = 0.4))  # Sequence incremented by 0.4
# Mixing types in a vector converts all elements to characters
s <- c('apple', 'red', 5, TRUE)
print(s)
# 1.2 Accessing Vector Elements
t <- c("Sun", "Mon", "Tue", "Wed", "Thurs", "Fri", "Sat")
u <- t[c(2,3,6)]  # Accessing specific elements
print(u)
v <- t[c(TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE)]  # Logical indexing
print(v)
x <- t[c(-2,-5)]  # Negative indexing to exclude elements
print(x)
y <- t[c(0,0,0,0,0,0,1)]  # 0/1 indexing
print(y)
# Conclusion: Vectors can be accessed using position, logical indexing, and negative indexing.
# 1.3 Vector Manipulation
v1 <- c(3,8,4,5,0,11)
v2 <- c(4,11,0,8,1,2)
print(v1 + v2)  # Addition
print(v1 - v2)  # Subtraction
print(v1 * v2)  # Multiplication
print(v1 / v2)  # Division
# Conclusion: Vector operations are element-wise, meaning operations occur between corresponding elements.
# 1.4 Vector Element Recycling
v1 <- c(3,8,4,5,0,11)
v2 <- c(4,11)
print(v1 + v2)  # Recycling smaller vector to match length
print(v1 - v2)
# Conclusion: If vectors are of different lengths, the shorter vector is recycled to match the longer one.
# 1.5 Vector Element Sorting
v <- c(3,8,4,5,0,11, -9, 304)
print(sort(v))  # Ascending order
print(sort(v, decreasing = TRUE))  # Descending order
# Sorting character vectors
v <- c("Red", "Blue", "yellow", "violet")
print(sort(v))  # Lexicographic order
print(sort(v, decreasing = TRUE))  # Reverse lexicographic order
# Conclusion: Sorting works on numeric and character vectors. Characters follow alphabetical order.
# 2.1 List Construction
list_data <- list("Red", "Green", c(21,32,11), TRUE, 51.23, 119.1)
print(list_data)
# 2.2 Naming List Elements
list_data <- list(c("Jan", "Feb", "Mar"), list("green", 12.3))
names(list_data) <- c("1st_Quarter", "A_Inner_list")
print(list_data)
# 2.3 Accessing List Elements
print(list_data[1])  # Accessing first element
print(list_data[2])  # Accessing second element (which is also a list)
print(list_data$A_Inner_list)  # Access using element name
print(which(list_data$`1st_Quarter` == "Feb"))  # Find index of value
# 2.4 List Manipulation
list_data[3] <- "New_element"  # Adding new element
print(list_data[3])
list_data[3] <- NULL  # Removing element
print(list_data[3])
list_data[2] <- "updated_element"  # Updating element
print(list_data[2])
# Conclusion: Lists allow adding, removing,
# Activity 1: Create a sequence of 20 numbers and calculate their squares
numbers <- seq(1, 20)  # Create a sequence from 1 to 20
squares <- numbers^2   # Compute the square of each number
print(squares)         # Display the results
# Activity 2: Display num1 and num2 with specific decimal points
num1 <- 0.956786
num2 <- 7.8345901
cat("num1 rounded to 2 decimal places:", round(num1, 2), "\n")
cat("num2 rounded to 3 decimal places:", round(num2, 3), "\n")
# Activity 3: Calculate and display the area of a circle
radius <- as.numeric(readline("Enter the radius of the circle: ")) # Get user input
cat("The area of the circle is:", area, "\n")  # Display the result
# Activity 1: Create a sequence of 20 numbers and calculate their squares
numbers <- seq(1, 20)  # Create a sequence from 1 to 20
squares <- numbers^2   # Compute the square of each number
print(squares)         # Display the results
# Activity 2: Display num1 and num2 with specific decimal points
num1 <- 0.956786
num2 <- 7.8345901
cat("num1 rounded to 2 decimal places:", round(num1, 2), "\n")
cat("num2 rounded to 3 decimal places:", round(num2, 3), "\n")
# Activity 3: Calculate and display the area of a circle
radius <- as.numeric(readline("Enter the radius of the circle: ")) # Get user input
cat("The area of the circle is:", area, "\n")  # Display the result
area <- pi * radius^2  # Calculate the area
# Activity 1: Create a sequence of 20 numbers and calculate their squares
numbers <- seq(1, 20)  # Create a sequence from 1 to 20
squares <- numbers^2   # Compute the square of each number
print(squares)         # Display the results
# Activity 2: Display num1 and num2 with specific decimal points
num1 <- 0.956786
num2 <- 7.8345901
cat("num1 rounded to 2 decimal places:", round(num1, 2), "\n")
cat("num2 rounded to 3 decimal places:", round(num2, 3), "\n")
radius <- as.numeric(readline("Enter the radius of the circle: ")) # Get user input
area <- pi * radius^2  # Calculate the area
cat("The area of the circle is:", area, "\n")  # Display the result
print("hello world")
gc()
library(shiny)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
library(tm)
library(proxy)
setwd("C:/Users/user/OneDrive - Universiti Teknologi PETRONAS/Jan 25/Data Science/Project Assignment/DataScienceFinalAssignment")
getwd()
movies_data <- read.csv("datasets/movies.csv")
check_missing_data <- function(data) {
missing_counts <- colSums(is.na(data))
missing_summary <- data.frame(Column = names(data), Missing_Values = missing_counts)
missing_summary <- missing_summary[missing_summary$Missing_Values > 0, ]
if (nrow(missing_summary) == 0) print("No missing values found!") else print(missing_summary)
return(missing_summary)
}
check_missing_data(movies_data)
# Function to recommend movies using TF-IDF
recommend_movies_tfidf <- function(data, movie_title, num_recommendations = 10) {
if (!"title" %in% colnames(data) || !"genres" %in% colnames(data)) {
stop("The dataset must contain 'title' and 'genres' columns")
}
# Create a corpus from genres
corpus <- VCorpus(VectorSource(data$genres))
# Apply TF-IDF transformation
dtm <- TermDocumentMatrix(corpus, control = list(weighting = weightTfIdf))
tfidf_matrix <- t(as.matrix(dtm))  # Transpose so movies are rows
# Ensure movie titles match the TF-IDF matrix order
if (nrow(tfidf_matrix) != nrow(data)) {
stop("Mismatch: TF-IDF matrix and dataset row counts differ.")
}
rownames(tfidf_matrix) <- data$title  # Assign movie titles as row names
# Find the index of the input movie
movie_index <- which(rownames(tfidf_matrix) == movie_title)
if (length(movie_index) == 0) {
stop("Movie not found in dataset")
}
# Compute cosine similarity
similarity_scores <- proxy::dist(tfidf_matrix, method = "cosine")
similarity_matrix <- as.matrix(similarity_scores)  # Convert to matrix
# Extract similarity scores for the input movie
movie_similarities <- similarity_matrix[movie_index, , drop = FALSE]
# Get top recommendations (excluding the input movie itself)
recommended_indices <- order(movie_similarities)[2:(num_recommendations + 1)]
recommendations <- rownames(tfidf_matrix)[recommended_indices]
print("Recommended Movies:")
print(recommendations)
return(recommendations)
}
recommend_movies_tfidf(movies_data, "Toy Story (1995)", 2)
# Function to recommend movies using TF-IDF
recommend_movies_tfidf <- function(data, movie_title, num_recommendations = 10) {
if (!"title" %in% colnames(data) || !"genres" %in% colnames(data)) {
stop("The dataset must contain 'title' and 'genres' columns")
}
# Create a corpus from genres
corpus <- VCorpus(VectorSource(data$genres))
# Apply TF-IDF transformation
dtm <- TermDocumentMatrix(corpus, control = list(weighting = weightTfIdf))
tfidf_matrix <- t(as.matrix(dtm))  # Transpose so movies are rows
# Ensure movie titles match the TF-IDF matrix order
if (nrow(tfidf_matrix) != nrow(data)) {
stop("Mismatch: TF-IDF matrix and dataset row counts differ.")
}
rownames(tfidf_matrix) <- data$title  # Assign movie titles as row names
# Find the index of the input movie
movie_index <- which(rownames(tfidf_matrix) == movie_title)
if (length(movie_index) == 0) {
stop("Movie not found in dataset")
}
# Compute cosine similarity
similarity_scores <- proxy::dist(tfidf_matrix, method = "cosine")
similarity_matrix <- as.matrix(similarity_scores)  # Convert to matrix
# Extract similarity scores for the input movie
movie_similarities <- similarity_matrix[movie_index, , drop = FALSE]
# Get top recommendations (excluding the input movie itself)
recommended_indices <- order(movie_similarities)[2:(num_recommendations + 1)]
recommendations <- rownames(tfidf_matrix)[recommended_indices]
print("Recommended Movies:")
return(recommendations)
}
recommend_movies_tfidf(movies_data, "Toy Story (1995)", 2)
